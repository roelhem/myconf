#+title: Mijn Configuratie
#+author: Roel Hemerik
#+email: myconf@roelweb.com
#+latex_class: book
#+latex_header_extra: \usepackage[autooneside=false,automark,headsepline]{scrlayer-scrpage}
#+property: header-args :tangle no :mkdirp yes :comments no :results silent :eval no-export
#+property: header-args:elisp :export code :lexical t
#+startup: fold
#+startup: showstars
#+startup: latexpreview

* About :nonum:

This is my literate config. Here, I put configuration in a more structured way so that
I can easier edit and search through it in Emacs.

The idea of this file is that both the source and the documentation are as close
together as possible.

The literate config should only contain configuration for systems where I also install
/Emacs/! This is because some distribution of emacs is required to build (tangle) this
file.

** Building this file

*** Using ~nix build~ command

The nix derivation to build this file is defined in the root [[./flake.nix]] file
and set as the ~myconf-literate-config~-package in the outputs. This means that
you can quickly build this file by running on any supported system (darwin/linux)
that has the [[https://nixos.org/download/][Nix Package Manager]] installed.

#+begin_src shell :tangle "build.sh" :shebang "#!/bin/bash sh"
nix --experimental-features 'nix-command flakes' build ~/.myconf#myconf-literate-config
#+end_src

Note that the command above does assume that this repository is cloned at the
standard location (~~/.myconf~). This is the only way in which I will use/test this
command, but it should work fine after adjust the command slightly.

* Setup

Here I define all the setup steps that are nessicary to build this file.

* Emacs

Please myself, try to use the following convention for naming things in this config:

 - *Any utility symbol* must start with ~~~.
 - *Any other symbol* must start with ~rh/~.
 - *Hooks* must end with ~-h~;

Furthermore, I should only use this file to configure things. If there is a large group
of functions, i should move it to a dedicated Elisp package as defined in the nix store
at [[./pkgs/emacs/elisp-packages/]]. This should also make it easier to limit the amount of
accidental dependencies as they are build using nix.

** Shared

These configuration items should be usable for both /Vanilla Emacs/ and /Doom Emacs/.
I should try to put as much configuration here to prepare for the switch from
/Doom Emacs/ to something else that is more compatible to nix.

*** Dependencies

**** Nix Home Packages :file:

List of dependencies that need to be installed in the home directory for this
config to work. This value should be added to the [[https://nix-community.github.io/home-manager/options.xhtml#opt-home.packages][home.packages]] option in the
nix config.

#+begin_src nix :tangle "emacs/shared/home-packages.nix"
pkgs: []
#+end_src

**** Nix Elisp Packages :file:

#+begin_src nix :tangle "emacs/shared/elisp-packages.nix"
epkgs: with epkgs; [
  treesit-grammars.with-all-grammars  # treesit gramars
  myconf             # elisp package with tools to manage myconf
  jwt                # jwt utilities
  persp-mode         # perspectives that work between frames
  jq-mode            # jq support
  unison-ts-mode     # Major mode for the Unison language
  xkcd               # access xkcd comics from emacs
  tidal              # Jam with Tidal Cycles in emacs
  nginx-mode         # Major mode to edit nginx config files.
  company-nginx      # Company autocomplete for nginx
  x509-mode          # Major mode for reading certificates
  vterm              # Terminal emulator for emacs
  evil-cleverparens
  org-tree-slide     # Slideshows using org mode
  polymode
  poly-markdown
  mmm-mode
  applescript-mode   # Editing applescript
  ob-applescript     # org babel for applescript
  flycheck-eglot
  # consult-eglot
]
#+end_src

*** Tuning
:PROPERTIES:
:header-args:elisp+: :tangle no :results value code replace
:END:

This section for configuration to ensure that emacs runs as smooth as possible.

#+NAME: tuning-host-specific
|                 | gcmh-high-cons-threshold | read-process-output-max | lsp-file-watch-threshold |
|-----------------+--------------------------+-------------------------+--------------------------|
| home-imac-x86   | 64MiB                    | 1MiB                    | 2000                     |
| home-studio     | 1GiB                     | 1MiB                    | 3000                     |

#+begin_src elisp :var items=tuning-host-specific name=(builder-attrs)
(alist-get "home-studio" items)
#+end_src

*** Configuration :file:
:PROPERTIES:
:header-args:elisp+: :tangle no :noweb-ref "shared-config"
:END:

**** Utilities

***** Common Predicates

#+begin_src elisp
(defun rh/major-mode-p (modesymb)
  "Checks if MODESYMB is the current major mode."
  (eq major-mode modesymb))
#+end_src

***** ~rx~ (regular expressions)

#+begin_src elisp
(rx-define nix-base32-char (any "0-9" "a-d" "f-n" "p-s" "v-z"))
(rx-define nix-hash (= 32 nix-base32-char))
(rx-define snake-case (seq (in (?a . ?z))
                           (* (in (?a . ?z) (?0 . ?9) ?_))))
(rx-define kebab-case (seq (in (?a . ?z))
                           (* (in (?a . ?z) (?0 . ?9) ?-))))
(rx-define camel-case (seq (in (?a . ?z))
                           (* (in (?A . ?Z) (?a . ?z) (?0 . ?9)))))
(rx-define pascal-case (seq (in (?A . ?Z))
                            (* (in (?A . ?Z) (?a . ?z) (?0 . ?9)))))
(rx-define constant-case (seq (in (?A . ?Z))
                              (* (in (?A . ?Z) (?0 . ?9) ?_))))
#+end_src

***** UUIDs

Just some functions to generate new random UUIDs. Inspired by [[http://xahlee.info/emacs/emacs/elisp_generate_uuid.html][~xah-insert-random-uuid~]].

#+begin_src elisp
(defvar rh/uuidgen-bin-path "uuidgen"
  "Path to the uuidgen binary.")

(defun rh/random-uuid (&optional lower)
  "Generate a random uuid using the 'uuidgen' cli tool.

Gives the uuid in lowercase if LOWER is non-nil."
  (let ((uuid (substring
               (shell-command-to-string rh/uuidgen-bin-path)
               0 -1)))
    (if lower (downcase uuid) uuid)))

(defun rh/insert-random-uuid (&optional lower)
  "Insert an UUID."
  (interactive)
  (insert (rh/random-uuid lower)))

(defun rh/insert-random-uuid-lowercase ()
  "Insert a lowercase UUID."
  (interactive)
  (rh/insert-random-uuid t))
#+end_src

***** Timestamps

#+begin_src elisp
(defun rh/insert-current-timestamp-s ()
  "Inserts the current unix timestamp at point."
  (interactive)
  (insert (format-time-string "%s" (current-time))))
#+end_src

***** Tree Sitter

#+begin_src elisp
(defun rh/treesit-append-font-lock-feature-at (level &rest features)
  "Adds treesit font lock FEATURES at the provided LEVEL."
  (setq treesit-font-lock-feature-list
        (cl-loop for i below level
                 collect (let ((old (nth i treesit-font-lock-feature-list)))
                           (if (= (1+ i) level)
                               (append features old)
                             old)))))

(defun rh/treesit-append-font-lock-settings (&rest args)
  "Adds treesit font lock settings."
  (when-let ((settings (apply #'treesit-font-lock-rules args)))
    (setq treesit-font-lock-settings
          (append treesit-font-lock-settings settings))))

(defun rh/treesit-font-lock-refresh ()
  "Recompute treesit font lock features and refontify."
  (interactive)
  (treesit-font-lock-recompute-features)
  (treesit-font-lock-fontify-region (point-min)
                                    (point-max)))

(defun rh/treesit-set-local-font-lock-level (val &optional buf)
  "Sets the treesit font lock level to VAL in BUF.

This sets the buffer-local value of `treesit-font-lock-level' and
recomputes the font lock features.

Uses the current buffer if BUF is nil or omitted."
  (interactive "Ntreesit-font-lock-level: ")
  (with-current-buffer (or buf (current-buffer))
    (setq-local treesit-font-lock-level val)
    (rh/treesit-font-lock-refresh)))

(defun rh/treesit-set-font-lock-level (val)
  "Sets `treesit-font-lock-level' to VAL in all buffers."
  (interactive "Ntreesit-font-lock-level: ")
  (set-default 'treesit-font-lock-level val)
  (when (treesit-available-p)
    (named-let loop ((res nil)
                     (buffers (buffer-list)))
      (if (null buffers)
          (mapc (lambda (b)
                  (rh/treesit-set-local-font-lock-level val b))
                res)
        (let ((buffer (car buffers)))
          (with-current-buffer buffer
            (if treesit-font-lock-settings
                (loop (append res (list buffer)) (cdr buffers))
              (loop res (cdr buffers)))))))))

(defun rh/treesit-language-at-point ()
  "Print the treesit language at the current point."
  (interactive)
  (message (symbol-name (treesit-language-at (point)))))

(defun rh/treesit-validate-font-lock-rules (query-specs)
  "Run `treesit-query-validate' on font lock rules"
  (let (current-language
        current-override
        current-feature
        (result nil))
    (while query-specs
      (let ((token (pop query-specs)))
        (pcase token
          (:language
           (let ((lang (pop query-specs)))
             (when (or (not (symbolp lang))
                       (null lang))
               (signal 'treesit-font-lock-error
                       `("Value of :language should be a symbol"
                         ,lang)))
             (setq current-language lang)))
          (:override
           (let ((flag (pop query-specs)))
             (when (not (memq flag '(t nil append prepend keep)))
               (signal 'treesit-font-lock-error
                       `("Value of :override should be one of t, nil, append, prepend, keep"
                         ,flag)))
             (setq current-override flag)))
          (:feature
           (let ((var (pop query-specs)))
             (when (or (not (symbolp var))
                       (memq var '(t nil)))
               (signal 'treesit-font-lock-error
                       `("Value of :feature should be symbol"
                         ,var)))
             (setq current-feature var)))
          ((pred treesit-query-p)
           (when (null current-language)
             (signal 'treesit-font-lock-error
                     `("Language unspecified, use :language keyword to specify a language for this query"
                       ,token
                       ,current-feature)))
           (push (list current-feature
                       current-language
                       (treesit-query-validate current-language token))
                 result))
          (_ (signal 'treesit-font-lock-error
                     `("Unexpected value" ,token ,current-feature))))))
    (nreverse result)))

(defun rh/treesit-font-lock-settings-validate (settings)
  (cl-loop for (query x feature override) in settings
           do (progn
                (message "%s" feature)
                (treesit-query-validate (treesit-query-language query) query))))
#+end_src

***** Frames

Some helper functions to work with frames.

#+begin_src elisp :lexical t
(defun rh/display-monitor-attributes-list (&optional display)
  "Shows the monitors of DISPLAY ordered from left to right."
  (seq-sort-by (lambda (x)
               (car (alist-get 'geometry x)))
             '<
             (display-monitor-attributes-list display)))

(defun rh/display-monitor-ppi (monitor-attrs)
  ""
  (pcase-let ((`(,x ,y ,width ,height) (alist-get 'geometry monitor-attrs))
              (`(,mm-width ,mm-height) (alist-get 'mm-size monitor-attrs)))
    (/
     (+ (/ (float width) (float mm-width) 0.039370078740157)
        (/ (float height) (float mm-height) 0.039370078740157))
     2)))

(defun rh/make-frame-on-nth-monitor (n &optional display parameters)
  "Makes a new frame on monitor N on DISPLAY with PARAMETERS."
  (when-let* ((monitor-workarea
               (alist-get 'workarea (nth n (rh/display-monitor-attributes-list display))))
              (geometry-parameters
               `((top . ,(nth 1 monitor-workarea))
                 (left . ,(nth 0 monitor-workarea)))))
    (make-frame (append geometry-parameters parameters))))

(defun rh/frame-left-monitor-attributes (&optional frame)
  "The attributes of the monitor on the left from FRAME."
  (pcase-let ((`(,left ,top) (frame-monitor-attribute 'workarea frame))
              (res nil))
    (dolist (element (rh/display-monitor-attributes-list) result)
      (pcase-let ((`(,fleft ,ftop ,fwidth ,fheigth) (alist-get 'geometry element)))
        (when (<= (+ fleft fwidth) left)
          (setq res element))
        (setq result res)))))

(defun rh/frame-right-monitor-attributes (&optional frame)
  "The attributes of the monitor on the right from FRAME."
  (pcase-let ((`(,left ,top) (frame-monitor-attribute 'workarea frame))
              (res nil))
    (dolist (element (nreverse (rh/display-monitor-attributes-list)) result)
      (pcase-let ((`(,fleft ,ftop ,fwidth ,fheigth) (alist-get 'geometry element)))
        (when (> fleft left)
          (setq res element))
        (setq result res)))))

(defun rh/make-frame-monitor-left (&optional parameters)
  "Makes a new frame on the left monitor."
  (interactive)
  (when-let* ((monitor-workarea
               (alist-get 'workarea (rh/frame-left-monitor-attributes)))
              (geometry-parameters
               `((top + ,(min 0 (nth 1 monitor-workarea)))
                 (left + ,(nth 0 monitor-workarea)))))
    (make-frame (append geometry-parameters parameters))))

(defun rh/make-frame-monitor-right (&optional parameters)
  "Makes a new frame on the left monitor."
  (interactive)
  (when-let* ((monitor-workarea
               (alist-get 'workarea (rh/frame-right-monitor-attributes)))
              (geometry-parameters
               `((top . ,(nth 1 monitor-workarea))
                 (left . ,(nth 0 monitor-workarea)))))
    (make-frame (append geometry-parameters parameters))))

(defun rh/frame-left-monitor-frames (&optional frame)
  "The attributes of the monitor on the left from FRAME."
  (pcase-let ((`(,left ,top) (frame-monitor-attribute 'workarea frame))
              (result nil))
    (dolist (element (rh/display-monitor-attributes-list))
      (pcase-let ((`(,fleft ,ftop ,fwidth ,fheigth) (alist-get 'geometry element)))
        (when (<= (+ fleft fwidth) left)
          (setq result (append result (alist-get 'frames element))))))
    result))

(defun rh/frame-right-monitor-frames (&optional frame)
  "The attributes of the monitor on the right from FRAME."
  (pcase-let ((`(,left ,top) (frame-monitor-attribute 'workarea frame))
              (result nil))
    (dolist (element (reverse (rh/display-monitor-attributes-list)))
      (pcase-let ((`(,fleft ,ftop ,fwidth ,fheigth) (alist-get 'geometry element)))
        (when (> fleft left)
          (setq result (append result (alist-get 'frames element))))))
    result))
#+end_src

#+begin_src elisp
(defun rh/select-frame-monitor-left (&optional frame)
  "Select and focus on frame on the monitor left to FRAME."
  (interactive)
  (let ((res nil))
    (dolist (left-frame (rh/frame-left-monitor-frames frame))
      (when (frame-visible-p left-frame)
        (setq res left-frame)))
    (when res
      (select-frame-set-input-focus res)
      res)))

(defun rh/select-frame-monitor-right (&optional frame)
  "Select and focus on frame on the monitor left to FRAME."
  (interactive)
  (let ((res nil))
    (dolist (left-frame (rh/frame-right-monitor-frames frame))
      (when (frame-visible-p left-frame)
        (setq res left-frame)))
    (when res
      (select-frame-set-input-focus res)
      res)))
#+end_src

***** Windows

****** Movement

#+begin_src elisp
(defun rh/windmove-left (&optional arg)
  "Move to left window"
  (interactive "P")
  (condition-case nil
      (windmove-left)
    (user-error
     (unless (rh/select-frame-monitor-left)
       (let ((newframe (rh/make-frame-monitor-left)))
         (toggle-frame-fullscreen newframe)
         (select-frame-set-input-focus newframe))))))

(defun rh/windmove-right (&optional arg)
  (interactive "P")
  (condition-case nil
      (windmove-right)
    (user-error
     (unless (rh/select-frame-monitor-right)
       (let ((newframe (rh/make-frame-monitor-right)))
         (toggle-frame-fullscreen newframe)
         (select-frame-set-input-focus newframe))))))
#+end_src

***** Buffers

#+begin_src elisp
(defun rh/buffer-major-mode (buf)
  (with-current-buffer buf
    major-mode))

(defun rh/reload-major-mode-buffers (&rest modes)
  "Reload all buffers with the provided major MODES"
  (dolist (mode modes)
    (dolist (buf (buffer-list))
      (with-current-buffer buf
        (when (eq major-mode mode)
          (funcall mode))))))
#+end_src

***** Modes

#+begin_src elisp
(defmacro rh/with-major-mode (mode &rest forms)
  "Run FORMS with a temporary buffer in mode mode"
  (declare (indent defun))
  `(with-temp-buffer
     (funcall ,mode)
     ,@forms))
#+end_src

**** Tuning

Section for configuration to ensure that emacs runs as smooth as possible.

***** Garbage Collection

#+begin_src elisp
(with-eval-after-load 'gcmh
  (setq gcmh-high-cons-threshold (* 1024 1024 1024)))
#+end_src

***** LSP

#+begin_src elisp
(setq read-process-output-max (* 1024 1024)
      lsp-file-watch-threshold 3000)
#+end_src

***** Display

#+begin_src elisp
(setq ns-use-native-fullscreen t)
#+end_src

**** Global Behavior

***** Emacs Server

#+begin_src elisp
;; (setq server-socket-dir "/Users/roel/.local/var/run/emacs")
#+end_src

***** Closing Window/Frame

#+begin_src elisp
(defun rh/close-window-or-frame ()
  "Close the selected window or frame if it is the last window."
  (interactive)
  (if (window-dedicated-p)
      (evil-window-delete)))
#+end_src

***** Local variables

#+begin_src elisp
(setq enable-local-variables :all)
#+end_src

**** Appearance

This section configures how emacs looks.

***** Glyphs

Characters indicating things.

#+begin_src elisp
(setq truncate-string-ellipsis "…")
#+end_src

***** Date/Time

Use normal European time formats.

#+begin_src elisp
(setq display-time-24hr-format t)
#+end_src

And globally enable ~display-time-mode~. I have no idea why my subconcious wants this...

#+begin_src elisp
(display-time-mode 1)
#+end_src

***** Faces

****** Extra font lock faces

Make things extra colorful!

The ~tree-sitter~ library, which I've grown quite font of, has a lot more faces than
the builtin ~treesit~ library (which uses the standard ~font-lock-*~ faces.) Here,
I will add some substitutes for those faces.

Firstly, a macro to make it easier to define those faces:

#+begin_src elisp
(defmacro rh/define-extra-font-lock-face (&rest args)
  "Defines extra font lock faces as a substitutes for tree-sitters faces.

Arguments should be lists of the following form:

        (NAME TSNAME)

Where NAME is the base name of the new face. The actual symbol-name for
the face will be \"rh/font-lock-NAME-face\".

TSNAME should be the suffix of the original \"tree-sitter-hl-face:*\" name.
The documentation is generated based on this TSNAME."
  `(progn
     ,@(cl-loop
        for (name tsname) in args
        for symb = (intern (concat "rh-font-lock-" (symbol-name name) "-face"))
        for doc = (concat "Font lock version of `" (symbol-name tsname) "'.")
        collect `(defface ,symb
                   '((t :inherit ,tsname))
                   ,doc))))

                                        ; (defface rh/font-lock-special-punctuation-face nil nil)
#+end_src

And now the extra faces that I want:

#+begin_src elisp
(rh/define-extra-font-lock-face
 (special-string tree-sitter-hl-face:string.special)
 (special-function tree-sitter-hl-face:function.special)
 (special-variable tree-sitter-hl-face:variable.special)
 (special-punctuation tree-sitter-hl-face:punctuation.special)
 (builtin-type tree-sitter-hl-face:type.builtin)
 (builtin-function tree-sitter-hl-face:function.builtin)
 (builtin-constant tree-sitter-hl-face:constant.builtin)
 (builtin-variable tree-sitter-hl-face:variable.builtin)
 (macro tree-sitter-hl-face:function.macro)
 (label tree-sitter-hl-face:label)
 (pragma tree-sitter-hl-face:pragma)
 (tag tree-sitter-hl-face:tag)
 (character tree-sitter-hl-face:character)
 (type-parameter tree-sitter-hl-face:type.parameter)
 (type-argument tree-sitter-hl-face:type.argument)
 (constructor tree-sitter-hl-face:constructor))

(defface rh-font-lock-property-deref-face
  '((t :slant italic :inherit font-lock-property-use-face))
  "Face for property dereferenced from the object.")

(defface rh-font-lock-method-name-face
  '((t :inherit font-lock-function-name-face))
  "Face for method definitions, like `font-lock-function-name-face'.")

(defface rh-font-lock-method-call-face
  '((t :slant italic :inherit font-lock-function-call-face))
  "Face for method calls, like `font-lock-function-call-face'.")

(defface rh-font-lock-template-string-face
  '((t :inherit font-lock-string-face))
  "Face for special strings that accept some kind of template syntax.")

(defface rh-font-lock-implicit-constructor-face
  '((t :inherit font-lock-builtin-face))
  "Face for brackets that implicitly construct things.")

(defface rh-font-lock-namespace-name-face
  '((t :inherit font-lock-type-face))
  "Face for namespace names.")

(defface rh-font-lock-namespace-use-face
  '((t :inherit rh-font-lock-namespace-name-face))
  "Face for references to namespace names.")
#+end_src

***** ANSI

****** Minor mode

#+begin_src elisp
(define-minor-mode rh/ansi-color-mode
  "Minor mode to display ansi colors in a buffer"
  :init-value nil
  (with-silent-modifications
    (ansi-color-apply-on-region 1 (buffer-size))))
#+end_src

**** Editor

This section configures how emacs behaves as a text editor.

#+begin_src elisp
(setq ns-function-modifier 'hyper)
#+end_src

***** Line numbers

This determines the style of line numbers in the editor.

#+begin_src elisp
(setq display-line-numbers-type 'relative)
#+end_src

The allowed values:

| Value       | Description           |
|-------------+-----------------------|
| ~nil~       | No line numbers       |
| ~t~         | Normal line numbers.  |
| ~'relative~ | Relative line numbers |

***** Behaviour

#+begin_src elisp
(setq undo-limit (* 64 1024 1024)
      auto-save-default t
      read-quoted-char-radix 16)
#+end_src

***** Tree Sitter (~treesit~)

Extra configuration for the builtin ~treesit~ package.

****** Font lock level

#+begin_src elisp
(set-default 'treesit-font-lock-level 4)
#+end_src

****** Font Lock Rules

******* Setup :nonum:

#+begin_src elisp
(defvar rh/treesit-font-lock-rules-alist nil
  "My custom font lock settings.")
#+end_src

***** Evil

I know, it is very evil, but I am used to it. (Also, it translates a bit better
to other editors.)

#+begin_src elisp
(setq evil-kill-on-visual-paste nil
      evil-respect-visual-line-mode t
      evil-ex-substitute-global t)
#+end_src

***** Perspectives

#+begin_src elisp
(setq doom-modeline-persp-name t)

(use-package persp-mode
  :hook (after-init . persp-mode)
  :bind (:map evil-normal-state-map
              ("] <tab>" . persp-next)
              ("[ <tab>" . persp-prev)))
#+end_src

***** External Editors

#+begin_src elisp
(defun rh/open-file-in-intellij ()
  "Opens the current file in intellij"
  (interactive)
  (let* ((filename (buffer-file-name))
         (line (number-to-string (locate-current-line-number)))
         (col (number-to-string (current-column)))
         (cmd (concat "phpstorm --line " line " --column " col " " filename)))
    (start-process-shell-command "open-phpstorm" "*open-phpstorm*" cmd)))
#+end_src

#+begin_src elisp
(map! :leader
      :prefix "o"
      "j" #'rh/open-file-in-intellij)
#+end_src

***** LSP

****** Eglot

Recently, [[https://joaotavora.github.io/eglot/][Eglot]] has become the built-in lsp client of emacs. Where possible,
I want to migrate to eglot.

#+begin_src elisp
(with-eval-after-load 'eglot
  (setq eglot-sync-connect 1
        eglot-autoshutdown t))
#+end_src

#+begin_src elisp
;; (use-package consult-eglot
;;   :defer t
;;   :init (with-eval-after-load 'eglot
;;           (keymap-set eglot-mode-map "<remap> <xref-find-apropos>" #'consult-eglot-symbols)))
#+end_src

Also add ~flycheck-eglot~ To ensure that eglot works with ~flycheck~.

#+begin_src elisp
(use-package flycheck-eglot
  :defer t
  :hook (eglot-managed-mode-hook . flycheck-eglot-mode))
#+end_src

****** ~lsp-mode~

****** Using both ~lsp-mode~ and ~eglot~.

Sometimes, I want to use [[https://joaotavora.github.io/eglot/][~eglot~]] and other times, I want to use [[https://emacs-lsp.github.io/lsp-mode/][~lsp-mode~]]. This
may even depend on the project on which I am working. Here, I define some helper
functions to make this easier.

#+begin_src elisp
(defun rh/buffer-lsp-driver ()
  "Gets the lsp driver of the current buffer.

Returns one of the following symbols:

  `\\='eglot' if the current buffer is managed by eglot.
  `\\='lsp-mode' if the current buffer is managed by lsp-mode.

Returns `nil' if the current buffer is not managed by any lsp driver."
  (cond ((and (featurep 'eglot)
              (eglot-managed-p)) 'eglot)
        ((and (featurep 'lsp-mode)
              lsp-mode) 'lsp-mode)
        (t nil)))

(defun rh/lsp-rename (&optional newname)
  "Rename the current symbol to NEWNAME."
  (interactive)
  (pcase (rh/buffer-lsp-driver)
    ('eglot
     (if newname (eglot-rename newname)
       (call-interactively 'eglot-rename)))
    ('lsp-mode
     (if newname (lsp-rename newname)
       (call-interactively 'lsp-rename)))
    (_ (error "No LSP driver for current buffer"))))
#+end_src


**** Filesystem

***** Myconf

#+begin_src elisp
(use-package myconf)
#+end_src

***** Special Files

#+NAME: emacs-config-special-files
| Name           | File Path           | Keybinding | sudo |
|----------------+---------------------+------------+------|
| literal-config | ~/.myconf/config.el | ,          | no   |
| hosts          | /etc/hosts          | h          | yes  |

#+begin_src elisp
(defun rh/doom-config-find-file ()
  (interactive)
  (find-file doom-user-dir))

(defun rh/doom-local-find-file ()
  (interactive)
  (find-file doom-local-dir))

(defun rh/doom-emacs-find-file ()
  (interactive)
  (find-file doom-emacs-dir))
#+end_src

***** LSP mode

LSP-mode has a strange file-watch behaviour that can slow things down. To limit
the amount of files that are watched in a project, we will add some additional
rules to ~lsp-file-watch-ignored-directories~ and ~lsp-file-watch-ignored-files~.

The directories and files added are mainly the common build/vendor/output directories,
which I do not edit commonly anyway.

#+begin_src elisp
(with-eval-after-load 'lsp-mode
  (let ((ld 'lsp-file-watch-ignored-directories)
        (lf 'lsp-file-watch-ignored-files))
    (add-to-list ld "[/\\\\]\\.nx\\'")
    (add-to-list ld "[/\\\\]vendor\\'")
    (add-to-list ld "[/\\\\]dist\\'")
    (add-to-list ld "[/\\\\]\\.postman\\'")
    (add-to-list ld "[/\\\\]\\.spago\\'")
    (add-to-list ld "[/\\\\]\\.phpunit.cache\\'")
    (add-to-list ld "[/\\\\]doomemacs")))
#+end_src

**** Tools

***** Which-key

Configures the helpers for key-bindings.

#+begin_src elisp
(setq which-key-idle-delay 0.5
      which-key-allow-multiple-replacements t
      which-key-show-operator-state-map t
      which-key-use-C-h-commands nil
      which-key-show-remaining-keys t)
#+end_src

***** Inspect load path

Quick tool to inspect the current load path

#+begin_src elisp
(defun rh/inspect-load-path ()
  "Show the load path in a new buffer"
  (interactive)
  (let ((buf (get-buffer-create "*rh/inspect-load-path*")))
    (with-current-buffer buf
      (erase-buffer)
      (dolist (el load-path)
        (insert " - " el ?\n)))
    (switch-to-buffer buf)))
#+end_src

**** Ecosystems

This sections focuses on configuration that is specific to different ecosystems. They are
grouped together so that it is easier for me to find the settings I want to change.

***** Org :ATTACH:
:PROPERTIES:
:ID:       630775f0-cdf3-495d-98d7-750a69cd2c2d
:END:

Settings specific to Emacs org-mode.

#+begin_src elisp
(setq org-directory "~/org/")
#+end_src

****** Org Protocol

#+begin_src elisp
(with-eval-after-load 'org
  (require 'org-protocol))
#+end_src

****** Appearance

#+begin_src elisp
(setq org-ellipsis " […] ")
#+end_src

****** Links

#+begin_src elisp
(with-eval-after-load 'org
  (add-to-list 'org-link-abbrev-alist '("myconf" . "file:~/.myconf/%s"))
  (add-to-list 'org-link-abbrev-alist '("workspace" . "file:~/workspace/%s")))
#+end_src

****** Tags

#+begin_src elisp
(setq org-group-tags t)
#+end_src

****** Todos

#+begin_src elisp
(setq-default org-todo-keywords
              '((sequence "TODO(t)" "HOLD(h)" "|" "DONE(t)")
                (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(c)" "|" "FIXED(f)")
                (sequence "[ ](T)" "[-](S)" "[?](W)" "|" "[X](D)")))
#+end_src

****** Logging

#+begin_src elisp
(setq org-log-into-drawer t)
#+end_src

****** Clock

#+begin_src elisp
(setq org-clock-idle-time 10)
#+end_src

****** LaTeX

#+begin_src elisp
(setq org-preview-latex-default-process 'dvisvgm)
#+end_src

****** Babel

#+begin_src elisp
(with-eval-after-load 'org
  (require 'ob-shell))
#+end_src

***** Elisp

****** Keybinds

#+begin_src elisp
(evil-define-key 'motion emacs-lisp-mode-map
  (kbd "<enter>") 'eval-defun
  (kbd "RET") 'eval-defun)
#+end_src

***** Nix

****** Store Path Highlights

#+begin_src elisp
(defface rh/nix-store-path nil
  "Face to highlight nix store paths.")

(define-minor-mode rh/nix-store-path-hl-mode
  "Highlight nix-store paths."
  :init-value nil
  (let* ((regexp (rx "/nix/store/" nix-hash))
           (keywords `((,regexp . rh/nix-store-path))))
    (if rh/nix-store-path-hl-mode
        (font-lock-add-keywords nil keywords)
      (font-lock-remove-keywords nil keywords))
    (font-lock-flush)))
#+end_src

****** Minor mode ~nix-prettify-mode~ (hide nix hashes)

Change the regular expression

#+begin_src elisp
(setq nix-prettify-regexp
      (rx "/" (or "store" "nar" "log") "/"
          (= 6 nix-base32-char)
          (group (= 26 nix-base32-char))))
#+end_src

****** LSP

#+begin_src elisp
(setq lsp-nix-nil-auto-eval-inputs nil)
#+end_src

***** F#

****** ob-fsharp :package:

#+begin_src elisp
(use-package ob-fsharp
  :after org)
#+end_src

****** eglot-fsharp :package:

#+begin_src elisp
;; (use-package eglot-fsharp)
#+end_src

***** Haskell

***** Unison

***** Protobuf

****** ~protobuf-mode~

#+begin_src elisp
(use-package protobuf-mode
  :mode (rx ".proto" string-end)
  :defer t)
#+end_src

***** JSON

****** jq :package:

#+begin_src elisp
(use-package jq-mode
  :commands (jq-interactively)
  :mode (rx ".jq" string-end)
  :interpreter "jq")
#+end_src

***** Typescript

****** Treesit font lock rules

#+begin_src elisp
(defun rh/typescript-treesit-font-lock-rules (language)
  "My treesit font lock rules for typescript."
  (let ((func-exp (tsx-ts-mode--font-lock-compatibility-function-expression language)))
    `(:language ,language
      :feature comment
      ([(comment) (hash_bang_line)] @font-lock-comment-face)

      :language ,language
      :feature constant
      (((identifier) @font-lock-constant-face
        (:match ,(rx string-start constant-case string-end)
                @font-lock-constant-face))
       [(true) (false) (null)] @font-lock-constant-face)

      :language ,language
      :feature keyword
      ([,@typescript-ts-mode--keywords] @font-lock-keyword-face
       [(this) (super)] @font-lock-keyword-face)

      :language ,language
      :feature string
      ((regex pattern: (regex_pattern)) @font-lock-regexp-face
       (string) @font-lock-string-face
       (template_string ["`" (string_fragment)] @rh-font-lock-template-string-face)
       (template_substitution ["${" "}"] @font-lock-misc-punctuation-face))

      :language ,language
      :override t
      :feature declaration
      ((,func-exp
        name: (identifier) @font-lock-function-name-face)
       (function_declaration
        name: (identifier) @font-lock-function-name-face)
       (function_signature
        name: (identifier) @font-lock-function-name-face)

       (method_definition
        name: (property_identifier) @rh-font-lock-method-name-face)
       (method_signature
        name: (property_identifier) @rh-font-lock-method-name-face)

       (required_parameter (identifier) @font-lock-variable-name-face)
       (optional_parameter (identifier) @font-lock-variable-name-face)
       (arrow_function
        parameter: (identifier) @font-lock-variable-name-face)

       (variable_declarator
        name: (identifier) @font-lock-function-name-face
        value: ,(vector `(,func-exp) '(arrow_function)))

       (variable_declarator
        name: (identifier) @font-lock-variable-name-face)

       (enum_declaration (identifier) @font-lock-type-face)

       (extends_clause value: (identifier) @font-lock-type-face)
       (extends_clause value: (member_expression
                               object: (identifier) @font-lock-type-face
                               property: (property_identifier) @font-lock-type-face))

       (variable_declarator
        name: (array_pattern
               (identifier)
               (identifier) @font-lock-function-name-face)
        value: (array (number) (,func-exp)))

       (catch_clause
        parameter: (identifier) @font-lock-variable-name-face)

       (import_clause (identifier) @font-lock-variable-name-face)
       (import_clause (named_imports (import_specifier
                                      alias: (identifier) @font-lock-variable-name-face)))
       (import_clause (named_imports (import_specifier
                                      !alias
                                      name: (identifier) @font-lock-variable-name-face)))
       (import_clause (namespace_import (identifier) @rh-font-lock-namespace-name-face)))

      :language ,language
      :feature identifier
      ((nested_type_identifier
        module: (identifier) @font-lock-type-face)

       (type_identifier) @font-lock-type-face
       (predefined_type) @rh-font-lock-builtin-type-face

       (new_expression
        constructor: (identifier) @rh-font-lock-constructor-face)

       (enum_body (property_identifier) @font-lock-constructor-face)
       (enum_assignment
        name: (property_identifier) @font-lock-constructor-face)

       (variable_declarator
        name: (identifier) @font-lock-variable-name-face)
       (for_in_statement
        left: (identifier) @font-lock-variable-name-face)

       (arrow_function
        parameters:
        [(_ (identifier) @font-lock-variable-name-face)
         (_ (_ (identifier) @font-lock-variable-name-face))
         (_ (_ (_ (identifier) @font-lock-variable-name-face)))]))

      :language ,language
      :feature property
      ((property_signature
        name: (property_identifier) @font-lock-property-name-face)
       (public_field_definition
        name: (property_identifier) @font-lock-property-name-face)

       (pair key: (property_identifier) @font-lock-property-use-face)
       ((shorthand_property_identifier) @font-lock-property-use-face)
       (member_expression
        property: (property_identifier) @rh-font-lock-property-deref-face))

      :language ,language
      :feature expression
      ((assignment_expression
        left: [(identifier) @font-lock-function-name-face
               (member_expression
                property: (property_identifier) @rh-font-lock-method-name-face)]
        right: ,(vector `(,func-exp) '(arrow_function)))

       (pair
        key: (property_identifier) @font-lock-method-name-face
        value: (arrow_function)))

      :language ,language
      :override t
      :feature function
      ((call_expression
        function: [(identifier) @font-lock-function-call-face
                   (member_expression
                    property: (property_identifier) @rh-font-lock-method-call-face)]))

      :language ,language
      :feature pattern
      ((pair_pattern
        key: (property_identifier) @font-lock-property-use-face
        value: [(identifier) @font-lock-variable-name-face
                (assignment_pattern left: (identifier) @font-lock-variable-name-face)])

       (array_pattern (identifier) @font-lock-variable-name-face)

       ((shorthand_property_identifier_pattern) @font-lock-variable-name-face))

      ;; TODO jsx

      :language ,language
      :feature number
      ((number) @font-lock-number-face
       ((identifier) @font-lock-number-face
        (:match ,(rx string-start (or "NaN" "Infinity") string-end) @font-lock-number-face)))

      :language ,language
      :feature operator
      ([,@typescript-ts-mode--operators] @font-lock-operator-face
       (ternary_expression ["?" ":"] @font-lock-operator-face))

      :language ,language
      :feature bracket
      ((["(" ")" "[" "]" "{" "}"]) @font-lock-bracket-face)

      :language ,language
      :override t
      :feature constructor-bracket
      ((object ["{" "}"] @rh-font-lock-implicit-constructor-face)
       (array ["[" "]"] @rh-font-lock-implicit-constructor-face))

      :language ,language
      :feature delimiter
      ((["," "." ";" ":"]) @font-lock-delimiter-face)

      :language ,language
      :feature escape-sequence
      :override t
      ((escape_sequence) @font-lock-escape-face)

      :language ,language
      :feature label
      ((labeled_statement
        label: (statement_identifier) @rh-font-lock-label-face
        ":" @rh-font-lock-label-face))

      :language ,language
      :override t
      :feature constructor
      ((import_specifier
        !alias
        name: (identifier) @rh-font-lock-constructor-face
        (:match ,(rx string-start pascal-case string-end) @rh-font-lock-constructor-face))
       (new_expression
        constructor: (identifier) @rh-font-lock-constructor-face)
       (member_expression
        object: (identifier) @rh-font-lock-constructor-face
        (:match ,(rx string-start pascal-case string-end) @rh-font-lock-constructor-face)))

      :language ,language
      :override t
      :feature type-import
      ((import_specifier
        "type"
        !alias
        name: (identifier) @font-lock-type-face)
       (import_specifier
        "type"
        alias: (identifier) @font-lock-type-face)
       (import_statement
        "type"
        (import_clause
         (named_imports (import_specifier
                         alias: (identifier) @font-lock-type-face))))
       (import_statement
        "type"
        (import_clause
         (named_imports (import_specifier
                         !alias
                         name: (identifier) @font-lock-type-face))))))))
#+end_src

****** ~typescript-ts-mode~ :package:

#+begin_src elisp
(defun rh/typescript-ts-mode-h ()
  "Custom typescript-ts-mode hook"
  (rh/treesit-append-font-lock-settings
   :language 'typescript
   :override t
   :feature 'constructor
   '((import_specifier
      name: (identifier) @rh-font-lock-constructor-face
      (:match "\\`[A-Z][A-Za-z0-9_]*\\'" @rh-font-lock-constructor-face))
     (new_expression
      constructor: (identifier) @rh-font-lock-constructor-face))

   :language 'typescript
   :override t
   :feature 'property-member
   '((member_expression
      property: (property_identifier) @rh-font-lock-property-deref-face))

   :language 'typescript
   :override t
   :feature 'method
   '((call_expression
      function: (member_expression
                 property: (property_identifier) @rh-font-lock-method-call-face)))

   :language 'typescript
   :override t
   :feature 'label
   '((labeled_statement
      label: (statement_identifier) @rh-font-lock-label-face
      ":" @rh-font-lock-label-face)))

  (setq-local treesit-font-lock-settings
              (apply #'treesit-font-lock-rules
                     (rh/typescript-treesit-font-lock-rules 'typescript)))

  ;; (rh/treesit-append-font-lock-feature-at 3 'punctuation)
  (rh/treesit-append-font-lock-feature-at 4 'constructor
                                          'type-import
                                          'property-member
                                          'template-string
                                          'constructor-bracket
                                          'method
                                          'label)
  (rh/treesit-font-lock-refresh))

(use-package typescript-ts-mode
  :mode
  ("\\.ts\\'" . typescript-ts-mode)
  :config
  (add-hook 'typescript-ts-mode-hook #'rh/typescript-ts-mode-h)
  (add-hook 'typescript-ts-mode-hook #'lsp))
#+end_src

***** Web

***** Cryptography

****** ~x509-mode~ :package:

#+begin_src elisp
(use-package x509-mode
  :commands (x509-viewcert
             x509-viewcrl
             x509-viewkey
             x509-viewpublickey
             x509-viewdh
             x509-viewreq
             x509-viewpkcs7
             x509-viewasn1
             x509-dwim)
  :defer t)
#+end_src

****** ~jwt~ :package:

#+begin_src elisp
(use-package jwt
  :autoload (jwt-create jwt-verify-signature)
  :commands (jwt-decode jwt-decode-at-point jwt-decode-region jwt-verify-current-token)
  :defer t)
#+end_src

***** Vue

****** ~vue-ts-mode~ :package:

#+begin_src elisp
(use-package vue-ts-mode
  :mode
  ("\\.vue\\'" . vue-ts-mode)
  :hook
  (vue-ts-mode . lsp)
  :defer t)
#+end_src

***** PHP

***** Go

****** ~go-ts-mode~ :package:

#+begin_src elisp
(use-package go-ts-mode
  :mode
  ("\\.go\\'" . go-ts-mode)
  ("/go\\.mod\\'" . go-mod-ts-mode)
  :defer t)

(add-hook 'go-ts-mode-hook #'lsp)
#+end_src

***** Bicep

****** ~bicep-ts-mode~ :package:

#+begin_src elisp
(use-package bicep-ts-mode
  :mode
  ("\\.bicep\\(param\\)?\\'" . bicep-ts-mode)
  :hook
  (bicep-ts-mode . lsp)
  :defer t)
#+end_src

****** ~lsp-bicep~ :package:

#+begin_src elisp
(use-package lsp-bicep
  :after (lsp-mode)
  :config
  (add-to-list 'lsp-language-id-configuration '(bicep-ts-mode . "bicep"))
  :defer t)
#+end_src

***** SQL

****** LSP

[[https://emacs-lsp.github.io/lsp-mode/page/lsp-sqls/]]

#+begin_src elisp
(setq lsp-sqls-workspace-config-path "root")
#+end_src

***** Nginx

****** ~nginx-mode~ :package:

#+begin_src elisp
(use-package nginx-mode
  :mode (rx "nginx.conf" string-end))
#+end_src

***** AppleScript

****** ~applescript-mode~

#+begin_src elisp
(use-package applescript-mode
  :mode (rx "." (or "applescript" "scpt") string-end)
  :interpreter "osascript"
  :defer t)
#+end_src

***** Arduino

Configuration to edit arduino code inside emacs.

****** LSP

Firstly, we will define the variable ~lsp-arduino-server-command~ in which we will store a list to define
how the lsp server should be started.

#+begin_src elisp
(defvar lsp-arduino-server-command nil
  "Command to start the arduino lsp server.")
#+end_src

#+begin_src elisp
(setq lsp-arduino-server-command `(,(executable-find "~/workspace/roelhem/arduino-language-server/arduino-language-server")
                                   "-clangd" ,(executable-find "clangd")
                                   "-cli" ,(executable-find "arduino-cli")
                                   "-cli-config" ,(file-truename "~/Library/Arduino15/arduino-cli.yaml")
                                   "-fqbn" "arduino:avr:uno"))
#+end_src

The [[file:./modules/home-manager/languages/arduino.nix][Nix configuration file for Arduino Language Development]] sets the ~lsp-arduino-server-command~ variable.
Therefore, we can immediately use this variable to add the lsp configurations.

#+begin_src elisp
(with-eval-after-load 'eglot
  (add-to-list 'eglot-server-programs
               `(arduino-ts-mode . ,(lambda (e) (progn lsp-arduino-server-command)))))
#+end_src

****** ~arduino-ts-mode~

#+begin_src elisp
(use-package arduino-ts-mode
  :mode (rx "." (or "pde" "ino") string-end)
  :config (add-hook 'arduino-ts-mode-hook 'eglot-ensure)
  :defer t)
#+end_src

****** ~arduino-cli-mode~

#+begin_src elisp
(use-package arduino-cli-mode
  :hook (arduino-ts-mode . arduino-cli-mode)
  :defer t)
#+end_src
**** Fixes & Workarounds

***** JSON Null-characters

The emacs json-parser does not like null-characters.

#+begin_src elisp
(advice-add 'json-parse-string :around
            (lambda (orig string &rest rest)
              (apply orig (s-replace "\\u0000" "" string)
                     rest)))

(advice-add 'json-parse-buffer :around
            (lambda (oldfn &rest args)
              (save-excursion
                (while (search-forward "\\u0000" nil t)
                  (replace-match "" nil t)))
                  (apply oldfn args)))
#+end_src

*** Snippets

** Doom Emacs Config

Here, I store the configuration that is specific for Doom emacs.
For now, I use [[https://github.com/doomemacs/doomemacs][Doom Emacs]] to configure emacs.

*** Dependencies

**** Nix Home Packages :file:

List of dependencies that need to be installed in the home directory for this
config to work. This value should be added to the [[https://nix-community.github.io/home-manager/options.xhtml#opt-home.packages][home.packages]] option in the
nix config.

#+begin_src nix :tangle "emacs/doom/home-packages.nix"
{ lib, stdenv, ghostscript, pngpaste }: [
  ghostscript
] ++ lib.optional stdenv.isDarwin pngpaste
#+end_src

**** Nix Elisp Packages :file:

#+begin_src nix :tangle "emacs/doom/elisp-packages.nix"
epkgs: with epkgs; [
  corfu
  nerd-icons-corfu
  corfu-terminal
  corfu-prescient
]
#+end_src

**** Doom straight (~packages.el~) :file:
:PROPERTIES:
:header-args:elisp+: :tangle "emacs/doom/packages.el"
:END:

#+begin_src elisp :comments none
;;; $DOOMDIR/packages.el -*- lexical-binding: t; -*-

(package! evil-escape :disable t)
#+end_src

*** Extra Init (~extra-init.el~) :file:
:PROPERTIES:
:header-args:elisp+: :tangle "emacs/doom/extra-init.el"
:END:

This file will be added at the top of the ~init.el~ file of the doom config.

#+begin_src elisp :comments no
;;; $DOOMDIR/extra-init.el -*- lexical-binding: t; -*-
#+end_src

*** Configuration (~config.el~) :file:
:PROPERTIES:
:header-args:elisp+: :tangle "emacs/doom/config.el"
:END:

This section defines the ~config.el~ file.

#+begin_src elisp :comments none :noweb yes
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

(setq custom-file "~/.local/emacs/custom.el")
(when (file-exists-p custom-file)
  (load custom-file))

;;; The shared Emacs config starts here.
<<shared-config>>
;;; The shared Emacs config ends here.

#+end_src

| Macro            | Description                                                   |
|------------------+---------------------------------------------------------------|
| ~load!~          | Load an external *.el file relative to the configuration.     |
| ~use-package!~   | To configure packages.                                        |
| ~after!~         | Running code after a package has loaded.                      |
| ~add-load-path!~ | Adding directories to the ~load-path~, relative to this file. |
| ~map!~           | Adding bindings.                                              |

**** Tools and Utils

***** Settings (~myconf~)

Some utility functions to manage this configuration. Might be a good idea to migrate this to a separate package in the future.

****** Configuration Variables

Here, define the configuration variables for the function we define later on.

#+begin_src elisp
(defconst myconf-config-org-file "~/.myconf/config.org"
  "The location of the config literal file.")

(defvar myconf-open-config-in-other-frame nil
  "Whether to open the config literal file in a new frame")

(defvar myconf-config-frame-name "Settings"
  "The name of the frame in which the settings should be opened.
Only has an effect of ~myconf-open-config-in-other-frame~ is non-nil")

(defvar myconf-config-workspace-name "*settings*"
  "The name of the workspace in which the settings will be opened.")
#+end_src

****** Open Settings

On MacOS, it should open the configuration just like any other application.

#+begin_src elisp
(map! "s-," #'myconf-open-config-org)
#+end_src

***** JWT-tokens

****** Get JWT Body

#+begin_src elisp
(defun jwt-parse-string (value &rest args)
  (let* ((parts (string-split value "\\."))
         (nth-decoded (lambda (n)
                        (apply 'json-parse-string
                         (base64-decode-string (nth n parts) t)
                         :object-type 'plist
                         :array-type 'list
                         args))))
    (append (mapcar nth-decoded '(0 1)) (nth 2 parts))))
#+end_src

***** Azure

****** Login

#+begin_src elisp
(defun az-login ()
  (shell-command "az login --allow-no-subscriptions"))
#+end_src

****** Getting Microsoft Graph Access Token

#+begin_src elisp
(defun ms-graph--get-access-token (&rest scopes)
  "Returns a new ms-graph access token."
  (let ((command "az account get-access-token --resource-type ms-graph --query accessToken --output tsv ")
        (scope-str (string-join (cons "--scope" scopes) " ")))
    (substring (shell-command-to-string (concat command scope-str)) 0 -1)))
#+end_src

****** CLI Transient

#+begin_src elisp :tangle no
(transient-define-prefix az-transient ()
  "Transient for the Azure az command line."
  :info-manual "THe az command line"
  [("q" "Quit" transient-quit-one)])

(transient-define-argument az-transient--output-a ()
  :description "Output format."
  :class 'transient-option
  :shortarg "-o"
  :argument "--output="
  :choices '("json" "jsonc" "none" "table" "tsv" "yaml" "yamlc")
  :default "json")
#+end_src

******* Account

#+begin_src elisp :tangle no
(transient-define-prefix az-account ()
  "Transient for the Azure ~az account~ cli."
  :info-manual "az account"
  ["Global Arguments"
   ("-h" "Show help message and exit." "--help")
   (az-transient--output-a)
   ("-q" "JMESPath query string." "--query")]
  ["Commands"
   ("ss" "Show" transient-quit-one)])
#+end_src

****** Keybindings

#+begin_src elisp :tangle no
(map! :leader
      :prefix "o"
      :desc "AZ cli" "s-a" #'az-transient)
#+end_src

***** Htmlize

#+begin_src elisp
(setq htmlize-html-major-mode 'web-mode
      htmlize-css-name-prefix "emacs-")
#+end_src

***** NX

#+begin_src elisp
(load! "~/.myconf/emacs/lisp/nx-mode.el")

(map! :leader
      "p n f" #'nx-project-find-file
      "p n R" #'nx-project-run-target)
#+end_src

***** Special files

#+begin_src elisp
(defun rh/open-doom-init ()
 (interactive)
 (find-file (concat (getenv "DOOMDIR") "init.el")))
#+end_src

**** Appearance

This section configures how emacs looks.

***** Theme

This sets the default theme for emacs.

#+begin_src elisp
(setq doom-theme 'one-dark)
#+end_src

To load another theme, use the ~load-theme~ function (=SPC h t=).

***** Colors

I am missing some colors!

****** One Dark

These are the colors of the original OneDark theme from Atom which I am used to.

#+begin_src elisp
(defconst one-dark-colors
  '(
    (coral . "#e06c75")
    (vivid-coral . "#ef596f")
    (dark . "#5c6370")
    (deep . "#23272e")
    (invalid . "#ffffff")
    (light-dark . "#7f848e")
    (light-white . "#abb2bf")
    (malibu . "#61afef")
    (deep-red . "#be5046")
    (black . "#282c34")
    (white . "#abb2bf")
    (light-green . "#afc3a1")
    (green . "#98c379")
    (dim-green . "#626e59")
    (vivid-green . "#89ca78")
    (error-red . "#f44747")
    (light-red . "#e06c75")
    (dark-red . "#be5046")
    (chalky . "#e5c07b")
    (light-yellow . "#e5c07b")
    (wiskey . "#d19a66")
    (dark-yellow . "#d19a66")
    (vivid-fountain-blue . "#2bbac5")
    (fountain-blue . "#56b6c2")
    (blue . "#61afef")
    (purple . "#c678dd")
    (magenta . "#c678dd")
    (vivid-purple . "#d55fde")
    (pink . "#c44482")
    (cyan . "#56b6c2")
    (gutter-gray . "#4b5263")
    (comment-gray . "#5c6370")))
#+end_src

The following function makes it easier to access these colors:

#+begin_src elisp
(defun one-dark-color (name)
  "Selects one of the original one-dark colors with name NAME."
  (alist-get name one-dark-colors))
#+end_src

***** Font faces

****** Fonts

Fonts can be set using the following variables. /Source: The default emacs =config.el= file./

| variable                   | description                                                        |
|----------------------------+--------------------------------------------------------------------|
| ~doom-font~                | The primary font to use.                                           |
| ~doom-variable-pitch-font~ | a non-monospace font (where applicable)                            |
| ~doom-big-font~            | Used for ~doom-big-font-mode~ (during presentations or streaming). |
| ~doom-unicode-font~        | To show unicode glyphs                                             |
| ~doom-serif-font~          | For the ~fixed-pitch-serif~ face.                                  |


#+begin_src elisp
(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'regular)
      doom-variable-pitch-font (font-spec :family "Fira Sans" :size 12))
#+end_src

Using ~s-=~ and ~s--~, changes the font size (default from /doom-emacs/). Lets make the step
as small as possible.

#+begin_src elisp
(setq doom-font-increment 1)
#+end_src

****** TreeSitter Highlighting

First some helper functions to make it easier to define extra tree-sitter faces.

#+begin_src elisp
(defun tshelper--get-captures (queries)
  "Returns a list of all unique capture symbols in QUERIES."
  (-distinct
   (cl-loop for query being the elements of queries
            append (--filter (and (symbolp it) (string-prefix-p "@" (symbol-name it)))
                             (-flatten query)))))

(defun tshelper--declare-capture-faces (queries &optional fmt)
  "Declares tree-sitter-hl-face faces for each symbol in ITEMS.

Optinally use FMT to specify the format of the face symbol names."
  (let ((fmt (or fmt "tree-sitter-hl-face:%s"))
        (items (tshelper--get-captures queries)))
   (cl-loop for item in items
            collect (let* ((name (symbol-name item))
                           (symb (intern (format fmt (string-remove-prefix "@" name)))))
                     (custom-declare-face symb nil
                      (format "Face for capture %s" name))))))

(defun tshelper-add-patterns (lang aftr queries)
  "Adds tree sitter highlight patterns defined by QUERIES to language LANG."
  (tree-sitter-hl-add-patterns lang queries)
  (with-eval-after-load aftr
   (tshelper--declare-capture-faces queries)))
#+end_src

Then add some faces that are missing anyway

#+begin_src elisp
(defface tree-sitter-hl-face:character nil nil)
#+end_src

****** Others

#+begin_src elisp
(custom-set-faces!
  `(tstools-query-match-1
    :foreground "#000"
    :background ,(doom-color 'orange)
    :weight bold)
  `(tstools-query-match-capture-label
    :slant italic
    :height 0.8
    :foreground ,(doom-color 'orange)))
#+end_src

***** Dashboard

#+begin_src elisp :tangle no
(defvar rh/xkcd-dashboard-banner t
  "Show the dashboard banner")

(defun rh/xkcd-get-json (&optional num)
  "Gets the xkcd info json for comic NUM. Defaults to the lastes."
  (let* ((num (or num 0))
         (url (if (eq num 0)
                  "https://xkcd.com/info.0.json"
                (format "https://xkcd.com/%d/info.0.json" num)))
         (out (xkcd-get-json url num))
         (json-assoc (json-read-from-string out)))
    (xkcd-cache-json num out)
    json-assoc))

(defface rh/xkcd-title
  '((t (:inherit info-title-1)))
  "Face for the xkcd title.")

(defface rh/xkcd-alt-text
  '((t (:inherit org-default)))
  "Face for the xkcd alt-text.")

(setq rh/xkcd-cur 0)

(defun rh/xkcd-insert-image (&optional num)
  "Insert xkcd image NUM at point"
  (let* ((json-assoc (rh/xkcd-get-json num))
         (img (cdr (assoc 'img json-assoc)))
         (num (cdr (assoc 'num json-assoc)))
         (alt (cdr (assoc 'alt json-assoc)))
         (safe-title (cdr (assoc 'safe_title json-assoc)))
         (file (xkcd-download img num))
         (title (format "%d: %s" num safe-title)))
    (insert (propertize title 'face 'rh/xkcd-title))
    (insert "\n\n")
    (xkcd-insert-image file num)
    (when (eq rh/xkcd-cur 0)
      (setq rh/xkcd-cur num))
    (insert "\n\n")
    (insert (propertize alt 'face 'rh/xkcd-alt-text))
    (insert "\n")
    num))

(defun rh/xkcd-doom-dashboard-banner ()
  "Shows an xkcd comic as the banner of the dashboard"
  (let ((point (point)))
    (when (and (display-graphic-p)
               rh/xkcd-dashboard-banner)
      (rh/xkcd-insert-image rh/xkcd-cur)
      (insert (make-string 2 ?\n)))))

(defun rh/load-xkcd-commic (num)
  ""
  (message "Load commic %d" num)
  (setq rh/xkcd-cur num)
  (+doom-dashboard-reload 'force))

(defun rh/xkcd-next (arg)
  "Next xkcd commic"
  (interactive "p")
  (let ((num (+ rh/xkcd-cur arg)))
    (when (> num xkcd-latest)
      (setq num xkcd-latest))
    (rh/load-xkcd-commic num)))

(defun rh/xkcd-previous (arg)
  "Prev xkcd commic"
  (interactive "p")
  (let ((num (- rh/xkcd-cur arg)))
    (when (< num 1)
      (setq num 1))
    (rh/load-xkcd-commic num)))

(defun rh/doom-dashboard-footer ()
  ""
  (insert (make-string 30 ?\n)))
#+end_src

****** Enabled widgets

#+begin_src elisp
(setq +doom-dashboard-functions
      '(doom-dashboard-widget-banner
        doom-dashboard-widget-shortmenu))
#+end_src

****** Keymap

#+begin_src elisp :tangle no
(setq +doom-dashboard-banner-padding '(0 . 100))

(map! :map '+doom-dashboard-mode-map
      "h" #'rh/xkcd-previous
      "p" #'rh/xkcd-previous
      "<left>" #'rh/xkcd-previous
      "l" #'rh/xkcd-next
      "n" #'rh/xkcd-next
      "<right>" #'rh/xkcd-next)
#+end_src

***** Corfu

#+begin_src elisp
(setq +corfu-want-ret-to-confirm 'minibuffer)
#+end_src

**** Key-bindings

This section configures my custom key-bindings.

***** Leader

Keybinds on the leader (~SPC~).

#+begin_src elisp
(define-key! [remap persp-switch-to-buffer] nil)
(map! :leader
      "<" #'persp-switch-to-buffer)
#+end_src

#+begin_src elisp
(map! :leader
      :prefix ("TAB" . "perspectives")
      "TAB" #'persp-switch
      "w" #'persp-window-switch
      "d" #'persp-kill
      "k" #'persp-kill
      "D" #'persp-remove-by-name
      "n" #'persp-add-new
      "]" #'persp-next
      "[" #'persp-prev)
#+end_src

#+begin_src elisp
(map! :map doom-leader-code-map
      "r" #'rh/lsp-rename)
#+end_src

****** Help (~SPC h~)

#+begin_src elisp
(map! :leader
      :prefix "h"
      "j" #'describe-keymap)
#+end_src

****** Buffer (~SPC b~)

#+begin_src elisp
(map! :leader
      :prefix ("b t" . "treesit")
      "l" #'rh/treesit-set-local-font-lock-level
      "L" #'rh/treesit-set-font-lock-level)
#+end_src

****** Insert (~SPC i~)

#+begin_src elisp
(map! :leader
      :prefix "i"
      :desc "Uppercase UUID" "G" #'rh/insert-random-uuid
      :desc "Lowercase UUID" "g" #'rh/insert-random-uuid-lowercase)

(map! :leader
      :prefix ("i t" . "Current Time")
      :desc "Timestamp in s" "s" #'rh/insert-current-timestamp)
#+end_src

****** Explain (~SPC e~)

******* Flycheck

#+begin_src elisp
(after! flycheck
  (map! :leader
        :prefix ("e" . "explain")
        :desc "Error at point" "e" #'flycheck-explain-error-at-point
        :desc "Error list" "E" #'list-flycheck-errors))
#+end_src

******* LSP

#+begin_src elisp
(after! lsp
  (map! :leader
        :prefix "e"
        :desc "Thing at point" "x" #'lsp-describe-thing-at-point
        :desc "LSP session" "L" #'lsp-describe-session))
#+end_src

****** Toggle (~SPC t~)

******* TreeSitter Debug

Explain the syntax as seen by ~tree-sitter~.

#+begin_src elisp
(map! :leader
      :prefix "t"
      :desc "Treesit Explore Mode" "t" #'treesit-explore-mode)
#+end_src

******* Nix-prettify

Toggle prettify modes

#+begin_src elisp
(map! :leader
      :prefix "t"
      :desc "Nix Prettify Mode" "N" #'nix-prettify-mode)
#+end_src

****** Code (~SPC c~)

******* TreeSitter Query

#+begin_src elisp
(map! :leader
      :prefix "c"
      "q" #'tree-sitter-query-builder)
#+end_src

****** Frames (~SPC F~)

Add a frames section to the leader.

#+begin_src elisp
(map! :leader
      :prefix ("F" . "frame")
      :desc "Right frame" "l" #'rh/select-frame-monitor-right
      :desc "Left frame" "h" #'rh/select-frame-monitor-left
      :desc "Close frame" "d" #'delete-frame
      :desc "Clear frame" "c" #'doom/delete-frame-with-prompt
      :desc "Undelete frame" "u" #'undelete-frame)
#+end_src

****** Window

#+begin_src elisp
(map! :leader
      :prefix ("w" . "window")
      "h" #'rh/windmove-left
      "l" #'rh/windmove-right)
#+end_src

****** Special Files (~SPC o ,~)

#+begin_src elisp
(defconst rh/special-files/hosts "/etc/hosts"
  "Location of the hosts file")

(defun rh/special-files-open/hosts ()
  "Opens the hosts file"
  (interactive)
  (doom/sudo-find-file rh/special-files/hosts))

(map! :leader
      :prefix ("o ," . "special files")
      :desc rh/special-files/hosts "h" #'rh/special-files-open/hosts)
#+end_src

***** Which-key

Configure the helpers for key-bindings

****** TODO Scrollable which-key pages

This might be do-able using ~which-key-show-next-page-no-cycle~ and ~which-key-show-previous-page-no-cycle~

****** Key replacements

Make the hints from =which-key= more readable by replacing common prefixes by symbols.

#+begin_src elisp
(after! which-key
  (pushnew! which-key-replacement-alist
            '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
            '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1")))
  (which-key-add-key-based-replacements
    "g z" "multiple-cursors"))
#+end_src

***** Restart LSP

#+begin_src elisp
(map! :after lsp-mode
      :leader
      "h r l" #'lsp-workspace-restart)
#+end_src

***** LSP describe session

#+begin_src elisp
(map! :after lsp-mode
      :leader
      "h s-l" #'lsp-describe-session)
#+end_src

***** Format buffer

#+begin_src elisp
(map! :leader
      "b f" #'+format/buffer)
#+end_src

**** Frames

***** MacOS Fullscreen

And after I toggled full-screen, I want the initial window to be as large as possible.

#+begin_src elisp
(add-to-list 'initial-frame-alist '(fullscreen-restore . maximized))
(add-to-list 'default-frame-alist '(left . 0))
(add-to-list 'default-frame-alist '(right . 0))
(add-to-list 'default-frame-alist '(fullscreen . fullscreen))
#+end_src

To ensure that emacs uses the MacOS-native way of fullscreen on toggle, I overwrite the =toggle-frame-fullscreen= function.

#+begin_src elisp
(defun toggle-frame-fullscreen (&optional frame)
  "Custom toggle-frame-fullscreen that works better with MacOS in my opinion"
  (interactive)
  (let ((fullscreen (frame-parameter frame 'fullscreen)))
    (if (memq fullscreen '(fullscreen fullboth))
	(let ((fullscreen-restore (frame-parameter frame 'fullscreen-restore)))
	  (if (memq fullscreen-restore '(maximized fullheight fullwidth))
	      (set-frame-parameter frame 'fullscreen fullscreen-restore)
	    (set-frame-parameter frame 'fullscreen nil)))
      (modify-frame-parameters
       frame `((fullscreen . fullscreen)
               (fullscreen-restore . ,fullscreen))))))
#+end_src

**** Languages

This section concerns the configuration specific to certain programming languages.

***** Haskell

My favorite language!

****** TreeSitter

******* Highlighting Patterns

#+begin_src elisp
(tshelper-add-patterns 'haskell 'haskell-mode
   [((comment) @haddock.multiline
     (.match? @haddock.multiline "^\\{-[|^](?s:.*)-}"))

    ((comment) @comment)
    ((pragma) @pragma)

    ((label) @haskell.label)

    (quasiquote [(quasiquote_start) (quasiquote_bar) "|]"] @haskell.qq.punctuation)
    ((quoter) @haskell.qq.quoter)
    ((quasiquote_body) @haskell.qq.body)

    (exp_type_application \. ("@") @haskell.type.application.operator)

    (type_literal (con_list) @haskell.list.type)
    (exp_literal (con_list) @haskell.list.constructor)
    (pat_literal (con_list) @haskell.list.constructor)

    (type_literal (con_unit) @haskell.unit.type)
    (exp_literal (con_unit) @haskell.unit.constructor)
    (pat_literal (con_unit) @haskell.unit.constructor)

    (type_list ["[" "]"] @haskell.list.type.punctuation)

    (type_tuple [(comma) "(" ")"] @haskell.tuple.type.punctuation)

    (["{" "}" "(" ")" "[" "]"] @punctuation.bracket)

    ((type) @type)

    ((type_variable) @type.argument)

    ((strict_type) @type.strict)])
#+end_src

******* Highlighting Overrides

First, define a variable that holds the mappings of the capture names to the faces.

#+begin_src elisp
(defvar +haskell-tree-sitter-hl-face-mapping nil
  "Holds the haskell specific mappings from capture names to faces.")
#+end_src

Also define a function that returns the associated type face symbol. Then, bind this to the ~haskell-mode~ local ~tree-sitter-hl-face-mapping-function~.

#+begin_src elisp
(defun +haskell-tree-sitter-hl-face-custom-get (cap)
  "Returns the type face symbol associated with the capture group
CAP in the mapping ~+haskell-tree-sitter-hl-face-mapping~."
  (alist-get cap +haskell-tree-sitter-hl-face-mapping nil nil #'equal))

(add-hook! haskell-mode
           (add-function :before-until (local 'tree-sitter-hl-face-mapping-function) #'+haskell-tree-sitter-hl-face-custom-get))
#+end_src

We can then fill this mapping variable. This can be done repeatedly without re-evaluating the functions above.

#+begin_src elisp
(setq +haskell-tree-sitter-hl-face-mapping
      '(("pragma" . +haskell-pragma)
        ("haddock.multiline" . font-lock-doc-face)
        ("type" . +haskell-type)
        ("haskell.type.application.operator" . +haskell-type-application-operator)
        ("haskell.list.type" . +haskell-type)
        ("haskell.list.constructor" . +haskell-constructor)
        ("constructor" . +haskell-constructor)
        ("haskell.unit.type" . +haskell-type)
        ("haskell.unit.constructor" . +haskell-constructor)
        ("haskell.list.type.punctuation" . +haskell-type-punctuation)
        ("haskell.tuple.type.punctuation" . +haskell-type-punctuation)
        ("haskell.label" . +haskell-label)
        ("haskell.qq.punctuation" . +haskell-qq-punctuation)
        ("haskell.qq.quoter" . +haskell-qq-quoter)
        ("haskell.qq.body" . +haskell-qq-body)
        ("type.strict" . +haskell-type-strict)))
#+end_src

Here, we define the extra faces we need.

#+begin_src elisp
(custom-set-faces! '(+haskell-lambda-symbol :inherit font-lock-keyword-face))
#+end_src

#+begin_src elisp
(defface +haskell-pragma nil nil)
(defface +haskell-lambda-symbol nil nil)
(defface +haskell-type-application-operator nil nil)
(defface +haskell-type-strict nil nil)
(defface +haskell-type nil nil)
(defface +haskell-type-constructor-punctuation nil nil)
(defface +haskell-type-punctuation nil nil)
(defface +haskell-constructor nil nil)
(defface +haskell-label nil nil)
(defface +haskell-qq-punctuation nil nil)
(defface +haskell-qq-quoter nil nil)
(defface +haskell-qq-body nil nil)

(custom-set-faces!
;;  `(+haskell-pragma :inherit haskell-pragma-face)
  `(+haskell-type-application-operator :weight bold)
  `(+haskell-type-strict :foreground ,(one-dark-color 'blue))
  `(+haskell-type :inherit font-lock-type-face)
  `(+haskell-type-punctuation :inherit font-lock-type-face)
;  `(+haskell-constructor :inherit font-lock-constructor-face
;                         :weight medium)
  `(+haskell-label :foreground ,(one-dark-color 'light-green))
  `(+haskell-qq-punctuation :foreground ,(one-dark-color 'pink))
  `(+haskell-qq-quoter :foreground ,(one-dark-color 'pink)
                       :weight normal)
  `(+haskell-qq-body :inherit org-block :foreground ,(one-dark-color 'green)))
#+end_src

****** HLS

These options configure the haskell language server.

******* Formatter

#+begin_src elisp
(after! lsp-haskell
  (setq lsp-haskell-formatting-provider "fourmolu"))
#+end_src

****** Interactive Mode

******* Hoogle Config

#+begin_src elisp
(custom-set-variables
 '(haskell-process-suggest-hoogle-imports t)
 '(haskell-interactive-types-for-show-ambiguous t))
#+end_src

******* Evil Bindings

Override some evil bindings so that insert mode will always insert at the prompt.

#+begin_src elisp
(defun haskell-interactive--get-prompt-point ()
  "Gets the start of the the current prompt"
  (marker-position haskell-interactive-mode-prompt-start))

(defun haskell-interactive--get-end-of-line (&optional pt)
  "Gets the end of the line, bypassing line wraps.
If PT is specified, find it's end of the line instead of the end of the line at the current prompt"
  (save-excursion
    (when pt (goto-char pt))
    (end-of-line)
    (point)))

(defun +haskell-interactive-goto-current-prompt ()
  "Goes to the the cursor to the current prompt"
  (interactive)
    (when (not (haskell-interactive-at-prompt))
      (goto-char haskell-interactive-mode-prompt-start)))

(defun +haskell-interactive-append ()
  "Append text at the next prompt."
  (interactive)
  (if (haskell-interactive-at-prompt)
      (call-interactively #'evil-append)
      (goto-char haskell-interactive-mode-prompt-start)
      (call-interactively #'evil-append-line)))

(defun +haskell-interactive-append-line ()
  "Append to end of line of the next prompt."
  (interactive)
  (when (not (haskell-interactive-at-prompt))
    (goto-char haskell-interactive-mode-prompt-start))
  (call-interactively #'evil-append-line))

(defun +haskell-interactive-insert ()
  "Insert text at the next prompt."
  (interactive)
  (when (not (haskell-interactive-at-prompt))
    (goto-char haskell-interactive-mode-prompt-start))
  (call-interactively #'evil-insert))

(defun +haskell-interactive-insert-line ()
  "Insert at the start of the prompt."
  (interactive)
  (goto-char haskell-interactive-mode-prompt-start)
  (call-interactively #'evil-insert))

(evil-define-operator +haskell-interactive-delete (beg end type register yank-handler)
  "Modification of the evil-delete to work in haskell interactive buffer.
Delete text from BEG to END with TYPE
Save in REGISTER or the kill-ring with YANK_HANDLER"
  (interactive "<R><x><y>")
  (let* ((beg (max (or beg (point)) (haskell-interactive--get-prompt-point)))
         (end (min (or end beg) (haskell-interactive--get-end-of-line))))
    (evil-delete beg end type register)
    (when (eq type 'line)
      (haskell-interactive-mode-bol))))

(defun +haskell-interactive-open-below ()
  "Opens a new line. Opens a prompt of the cursor is not a te new line"
  (interactive)
  (cond ((<= (point) (haskell-interactive--get-prompt-point))
         (goto-char (point-max))
         (insert "\n")
         (haskell-interactive-mode-prompt)
         (call-interactively #'+haskell-interactive-insert))
        (t
         (call-interactively #'evil-open-below))))

(map! :after haskell-interactive-mode
      :map haskell-interactive-mode-map
      :n "][" #'haskell-interactive-mode-prompt-next
      :n "[[" #'haskell-interactive-mode-prompt-previous
      :n "a" #'+haskell-interactive-append
      :n "A" #'+haskell-interactive-append-line
      :n "d" #'+haskell-interactive-delete
      :n "i" #'+haskell-interactive-insert
      :n "I" #'+haskell-interactive-insert-line
      :n "o" #'+haskell-interactive-open-below
      :n "RET" #'haskell-interactive-mode-return)
#+end_src

Next, we define some evil-like bindings to quickly walk through the interactive console.

******* Toggle print mode

This command toggles the mode in which the results of ghci will be displayed.

#+begin_src elisp
(defun haskell-interactive-toggle-print-mode ()
  (interactive)
  (setq haskell-interactive-mode-eval-mode
        (intern
         (ido-completing-read "Eval result mode"
                              '("fundamental-mode"
                                "haskell-mode"
                                "ghc-core-mode")))))

(after! haskell-interactive-mode
  (setq haskell-interactive-mode-eval-mode 'haskell-mode))
#+end_src

******* Enable lookups

Enables lookups from a GHCI-window!

#+begin_src elisp
(set-lookup-handlers! 'haskell-interactive-mode
  :definition #'haskell-mode-jump-to-def)
#+end_src

******* Pop-ups

Pop-up of the repl itself:

#+begin_src elisp
(after! haskell-session
 (defun +haskell-interactive-session-buffer? (name)
   "Checks if the provided name is an haskell interactive session"
   (let ((session-names (mapcar
                         (lambda (item) (format "*%s*" (alist-get 'name item)))
                         haskell-sessions)))
   (member name session-names)))
 (set-popup-rule! #'+haskell-interactive-session?
   :size 80
   :actions #'+display-buffer-in-side-window
   :side 'right
   :vslot -1
   :modeline nil))
#+end_src

Pop-up that shows the errors:

#+begin_src elisp
(set-popup-rule! "^\\*HS-Error\\*" :size 12 :quit t :vslot 0)
#+end_src

****** TODO Haddock editing

Lots of improvements can be made here!

- Insert functions for hints at
  - Functions
  - Arguments
  - ...
- Insert functions, syntax highighting and maybe completion for
  - Types links ( ~'T'~)
  - Variable links (~'foo''~)
  - directives (~@source~)
  - italic (~/italic/~)
  - bold (~__bold__~)
- Better line breaks while editing a haddock block.
  - Keep the lines together in multi-line blocks (~{-| like this -}~)
  - Adding new lines in single line blocks

Should be implemented using the [[https://haskell-haddock.readthedocs.io/en/latest/markup.html][the haddock markup documentation]].

****** TODO Find definitions everywhere

I would like to have find definition (aka ~K~) also in the response of ~haskell-interactive-mode~ and in ~lsp-help-mode~.

Some possibilities are:
- Leverage hoogle to find those definitions.
- Use ~haskell-process-do-info~ as it seems to work in most cases...

****** TODO Cleanup imports

It would be nice to have one function with one key-binding that cleans up all the imports in a Haskell module without jumping to the imports and calling the lsp code-actions manually.

****** Stack...

Place to put functions to help with managing stack projects.

******* TODO Jump to ~stack.yaml~

******* TODO Jump to ~package.yaml~

******* TODO Add dependency to ~package.yaml~

****** Menu

Settings for the haskell menu.

Firstly, it should open in a popup!

#+begin_src elisp
(after! haskell-mode
  (set-popup-rule!
    (lambda (arg) (string-equal arg haskell-menu-buffer-name))
    :size 6 :quit t :slot -1))

#+end_src

Then define the toggle function.

#+begin_src elisp
(setq haskell-menu-buffer-name "*haskell-menu*")

(defun +haskell-menu/toggle ()
    "Toggles the Haskell sessions menu"
    (interactive)
    (or (get-buffer haskell-menu-buffer-name)
        (with-current-buffer (get-buffer-create haskell-menu-buffer-name) (haskell-menu-mode)))
    (if-let (win (get-buffer-window haskell-menu-buffer-name))
            (delete-window win)
            (pop-to-buffer haskell-menu-buffer-name)
            (haskell-menu-revert-function nil nil)))
#+end_src

Finally, we add a keybinding to toggle the haskell menu.

#+begin_src elisp
(map! :leader :prefix "o" :n "h" #'+haskell-menu/toggle)
#+end_src

****** Hoogle

******* Via CLI

Defines how the hoogle command should be called from the CLI. Then also define an evil-command so that hoogle can be accessed via ~:hoogl ...~.

#+begin_src elisp
(after! haskell-hoogle
  (setq haskell-hoogle-command "hoogle --count=40")

  (evil-define-command +evil:hoogle (&optional query)
    "Searches hoogle"
    (interactive "<a>")
    (haskell-hoogle query))

  (evil-ex-define-cmd "hoogl[e]" '+evil:hoogle))
#+end_src

******* Via Browser

First add hoogle to list of web lookups.

#+begin_src elisp
;; (add-to-list '+lookup-provider-url-alist '("Hoogle" "https://hoogle.haskell.org/?hoogle=%s"))
#+end_src

******* Keybindings

#+begin_src elisp
(map!
 :after haskell-hoogle
 :leader
 "s h" #'haskell-hoogle)
#+end_src

****** Fixes

Somehow, I needed to add this to make ~haskell-mode~ work...

#+begin_src elisp
(setq flymake-allowed-file-name-masks nil)

(add-to-list 'flymake-allowed-file-name-masks
             '("\\.hs\\'" haskell-flymake-init))
#+end_src

****** Keybindings

******* For ~haskell-mode~

The mode for editing haskell files.

#+begin_src elisp
(map! :after haskell-mode
      :map haskell-mode-map
      :localleader
      "r" #'haskell-process-load-file
      :desc "compile" "b" #'haskell-compile
      :desc "goto imports" "i" #'haskell-navigate-imports)
#+end_src

******* For ~haskel-cabal-mode~

#+begin_src elisp
(map! :after haskell-cabal
      :map haskell-cabal-mode-map
      :localleader
      :desc "compile" "b" #'haskell-compile)
#+end_src

******* For ~haskell-interactive-mode~

The mode for running ~ghci~.

#+begin_src elisp
(map! :after haskell-interactive-mode
      :map haskell-interactive-mode-map
      :localleader
      :desc "Toggle GHCI output" "t" #'haskell-interactive-toggle-print-mode)
#+end_src

******* For ~haskell-error-mode~

The mode for errors that occur in ~ghci~.

#+begin_src elisp
(map! :map haskell-error-mode-map
      :vinm "q" #'+popup/quit-window
      :vinm "<escape>" #'+popup/quit-window)
#+end_src

***** Unison

****** LSP

#+begin_src elisp
; (push '((unison-ts-mode) "127.0.0.1" 5757) eglot-server-programs)
#+end_src

***** Web

****** No LSP format.

The lsp formatter is conflicting with prettier. Better to always use prettier if possible.

#+begin_src elisp
(setq-hook! 'web-mode-hook +format-with-lsp nil)
#+end_src

***** Vue

****** Ensure Eglot uses Volar

The following function generates the volar configuration for eglot.

#+begin_src elisp
(defun vue-eglot-init-options ()
             (let ((tsdk-path (expand-file-name
                               "lib"
                               (string-trim-right (shell-command-to-string "npm list --global --parseable typescript | head -n1 | tr -d \"\n\""))
                               )))
               `(:typescript (:tsdk ,tsdk-path
                              :languageFeatures (:completion
                                                 (:defaultTagNameCase "both"
                                                  :defaultAttrNameCase "kebabCase"
                                                  :getDocumentNameCasesRequest nil
                                                  :getDocumentSelectionRequest nil)
                                                 :diagnostics
                                                 (:getDocumentVersionRequest nil))
                              :documentFeatures (:documentFormatting
                                                 (:defaultPrintWidth 100
                                                  :getDocumentPrintWidthRequest nil)
                                                 :documentSymbol t
                                                 :documentColor t)))))
#+end_src

Then, we add it to the list of eglot language servers.

#+begin_src elisp
(after! eglot
  (add-to-list 'eglot-server-programs
               `(vue-mode . ("vue-language-server" "--stdio" :initializationOptions ,(vue-eglot-init-options))))
  (add-hook 'vue-mode-hook 'eglot-ensure))
#+end_src

***** PHP

****** Intelephense

The =lsp=-package fogot to implement some lsp-settings for the =intelephense=-server. Therefore, I'll add them here.

#+begin_src elisp
(after! lsp
  (defcustom-lsp lsp-intelephense-document-root "apps/backend/public/index.php"
    "The directory of the entry point to the application (index.php)."
    :type 'string
    :group 'lsp-intelephense
    :lsp-path "intelephense.environment.documentRoot")
  (defcustom-lsp lsp-intelephense-include-paths []
    "The include paths"
    :type '(repeat string)
    :group 'lsp-intelephense
    :lsp-path "intelephense.environment.includePaths"))
#+end_src

***** C#

****** Enable LSP-mode

#+begin_src elisp
(add-hook 'csharp-tree-sitter-mode-hook #'lsp!)
#+end_src

***** Brewfile

****** Major-mode

A ~Brewfile~ is essentially just a stripped-down version of a ~ruby~ script. Therefore, we can use ~ruby-mode~ to define a new mode for Brewfiles.

#+begin_src elisp
(define-derived-mode brewfile-mode ruby-mode "Brewfile")
#+end_src

For now, we will only activate this mode for files named =Brewfile= or files with the the =.Brewfile= extension.

#+begin_src elisp
(add-to-list 'auto-mode-alist '("[/.]Brewfile\\'" . brewfile-mode))
#+end_src

***** GraphQL

****** Enable GraphQL in ~js~ and ~ts~.

#+begin_src elisp
(after! mmm-mode
  (mmm-add-classes '((js-graphql
                      :submode graphql-mode
                      :face mmm-declaration-submode-face
                      :front "[^a-zA-Z]gql`"
                      :back "`")))
  (mmm-add-mode-ext-class 'typescript-ts-mode nil 'js-graphql)
  (setq mmm-global-mode 'maybe))
#+end_src

***** Nix

#+begin_src elisp
(setq lsp-nix-nil-auto-eval-inputs nil)
#+end_src
**** Modes

This section concerns the configuration specific to modes.

***** Eglot

#+begin_src elisp
(with-eval-after-load 'eglot
  (set-lookup-handlers! 'eglot--managed-mode
    :definition #'xref-find-definitions
    :references #'xref-find-references
    :implementations #'eglot-find-implementation
    :type-definition #'eglot-find-typeDefinition
    :documentation #'eldoc))

(set-popup-rule! "^\\*eldoc" :side 'right :width 120)
#+end_src

***** Tidal

****** Parameters

#+begin_src elisp
(setq tidal-boot-script-path "~/workspace/tidal/BootTidal.hs")
#+end_src

***** Org

****** Tree Slides

******* Setup

#+begin_src elisp
(use-package org-tree-slide
  :custom
  (org-image-actual-width nil))
#+end_src

******* Keybindings

#+begin_src elisp
(map! :after org-tree-slide
      :map org-tree-slide-mode-map
      "<f5>" 'org-tree-slide-move-previous-tree
      "<f6>" 'org-tree-slide-move-next-tree)
#+end_src

****** Keybindings

On the local leader:

#+begin_src elisp
(map! :after org
      :map org-mode-map
      :localleader
      "H" #'org-insert-heading
      :desc "tangle" "RET" #'org-babel-tangle)
#+end_src

***** Yasnippets

Configures ~snippet-mode~ for ~yasnippets~.

#+begin_src elisp
(map! :after yasnippet
      :map snippet-mode-map
      :localleader
      :desc "Load buffer" "b" #'yas-load-snippet-buffer
      :desc "Load buffer and close" "RET" #'yas-load-snippet-buffer-and-close
      :desc "Tryout snippet" "t" #'yas-tryout-snippet)
#+end_src

*** Outputs

**** Emacs Config Module :file:

#+begin_src nix :tangle "emacs/doom/emacs-module.nix"
{ lib, ... }:

with lib;

{
  config.doom = {
      file."config.el".source = ./config.el;
      file."packages.el".source = ./packages.el;
      file."extra-init.el".source = ./extra-init.el;
  };
}
#+end_src

**** Nix derivation :file:

#+begin_src nix :tangle "emacs/doom/buildDoomDir.nix"
{
  lib,                 # The combined nix library of my emacs config.
  emacs,               # The derivation for the emacs binary used to run doom emacs.
  themesSource,        # Path to the directory that contains the themes.
  setq ? {},           # Gets injected in the init.el file.
  homeDirectory ? "~", # Path to the home directory of the user.
  ...
}:

let

  inherit (lib) mkDefault;

in

{
  emacsPackage = emacs;
  localDir = mkDefault "${homeDirectory}/.local/emacs/doom/";
  init.setq = setq;
  file = {
    "themes" = {
      source = themesSource;
      copy = true;
    };
    "config.el" = {
      source = ./config.el;
      copy = true;
    };
    "packages.el" = {
      source = ./packages.el;
      copy = true;
    };
    "extra-init.el" = {
      source = ./extra-init.el;
      copy = true;
    };
  };
}
#+end_src

** Snippets

*** YaSnippet

**** Haskell

***** import ~Data.Text~ :file:

#+begin_src snippet :tangle "emacs/snippets/yasnippet/haskell-mode/Text"
# name: import Data.Text
# key: <T
# group: imports
# --
import Data.Text (Text)
import qualified Data.Text as Text
#+end_src

***** import ~Data.Text.Lazy~ :file:

#+begin_src snippet :tangle "emacs/snippets/yasnippet/haskell-mode/TextLazy"
# name: import Data.Text.Lazy
# key: <TL
# group: imports
# condition: (looking-back "^<TL" nil)
# --
import qualified Data.Text.Lazy (Text as Lazy) as Text
import qualified Data.Text.Lazy as Text.Lazy
#+end_src

*** Outputs

**** Nix Emacs Config Module :file:

#+begin_src nix :tangle "emacs/snippets/emacs-module.nix"
{ lib, config, ... }: with lib;

let
  cfg = config.snippets;
in
{
  options.snippets.enable = mkOption {
    type = types.bool;
    default = true;
  };

  config = mkIf cfg.enable {
    initDirectory.file.snippets.source = ./yasnippet;
    doom.file.snippets.source = ./yasnippet;
  };
}
#+end_src

* LaTeX

I can configure LaTeX here because I will only write LaTeX with emacs anyway.

$\mathcal{C}(N)$

** TeX Live

Configuration of the [[https://www.tug.org/texlive/][TeX Live]] libraries.

*** Nix Dependencies

Here, I define which packages I need from nix. See the article about
[[https://nixos.wiki/wiki/TexLive][TexLive in the NixOS wiki]] for a description on how this works.

#+begin_src nix :tangle "latex/texlive/extraPackages.nix"
tpkgs: {
  inherit (tpkgs)
    scheme-medium
    dvisvgm
    dvipng
    wrapfig
    amsmath
    ulem
    hyperref
    capt-of
    ;
}
#+end_src

* Outputs

** Nix Results (~results.nix~) :file:

This expression is evaluated by nix and returned as the results attribute of
the derivation that tangled this file.

#+begin_src nix :tangle "results.nix"
{ lib, callPackage, ... }:
let
  inherit (builtins) filter concatMap;
  inherit (lib) filesystem strings lists;

  # List of all the output files after tangling this file.
  outFiles = filesystem.listFilesRecursive ./.;

  # Function that takes a suffix and returns a list of all output
  # files that end with the provided suffix.
  outFilesEndingWith = suffix: filter (strings.hasSuffix suffix) outFiles;
in
{
  inherit outFiles outFilesEndingWith;
  # The packages that should be added to the home.packages option
  # from home-manager.
  homePackages = concatMap
    (file: callPackage (import file) { })
    (outFilesEndingWith "home-packages.nix");

  # The elisp package dependencies.
  emacs.elispPackages = epkgs: concatMap
    (file: import file epkgs)
    (outFilesEndingWith "elisp-packages.nix");

  # Legacy options for the doom config directory.
  emacs.doom.buildDoomDir = import ./emacs/doom/buildDoomDir.nix;

  # TexLive latex package definitions.
  texlive.extraPackages = import ./latex/texlive/extraPackages.nix;

  # Module for emacs configurations.
  emacs.module.imports = outFilesEndingWith "emacs-module.nix";
}
#+end_src

* Not Yet Decided

** TODO Decide a new theme

- ~doom-ayu-mirage~

* References :nonum:
